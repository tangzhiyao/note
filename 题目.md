# 浏览器

1. 对浏览器内核的理解：

   浏览器内核主要分两部分：渲染引擎、js引擎；

   渲染引擎：负责获取网页内容（HTML、XML、图像等），计算网页的显示方式。不同引擎渲染的方式不同。

   js 引擎：解析和执行 javascript 来实现网页的动态效果；

   最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。 

2. 常见的浏览器内核：

   * Trident 内核：IE、360、搜狗 [又称MSHTML]

   * Gecko 内核：Netscape6 及以上版本

   * Presto 内核：Opera7 及以上

   * Webkit 内核：Safari，Chrome等

   * blink 内核：谷歌

     **针对不同浏览器的 css 属性前缀：**

   * -webkit- ：safari、chrome

   * -moz-：火狐

   * -ms-：ie

   * -o-：opera

3. cookies、sessionStorage和localStorage区别：

   cookies：

   * 大小受限，大约在4kb左右；
   * 未设置过期时间，则直到关闭浏览器前生效；设置过期时间则保存到本地直到过期时间，或手动删除；
   * 每次请求都需要发送 cookies；

   sessionStorage：

   * 大小受限，大约在5mb左右；
   * 生命周期直到关闭浏览器
   * 保存在本地，不与服务器交互通信；
   * 只能存储字符串，可以通过 JSON.stringify 和 parse 方法处理对象
   * window.sessionStorage 获取；

   localStorage：

   * 生命周期永久，只能手动删除；
   * window.localStorage 获取；
   	 其他同 sessionStorage；	

4. 浏览器兼容性问题：

   1. 不同浏览器的 margin 和 padding 不同。

      解决：css 开头使用通配符（*），设置 `padding: 0; margin: 0 ` ;

   2. 多个 img 图片并排又间距。

      解决：使用 float ；

5. 两个并排的元素之间有空白。

   原因：标签之间的空格或换行引起的。

   解决：可以将 font-size 设为 0；但要注意标签的css样式继承。

6. 状态码：

   1xx：表示请求已接受，继续处理

   2xx：成功状态

   * 200：请求成功；

   3xx：重定向状态

   * 301：永久重定向；
   * 302：临时重定向；
   * 304：文件未修改，可以直接使用缓存文件

   4xx：客户端出错

   * 400：客户端发送请求错误；
   * 403：资源不被允许访问；
   * 404：请求资源不存在；

   5xx：服务器出错

   * 500：服务器错误；

7. HTTP 缓存机制：

   在请求静态文件的时候(图片，css，js等一些不常变化的文件)，浏览器会将这些文件存储起来，优化用户浏览体验；

   两种缓存规则：

   * 强制缓存
   * 对比缓存

   

8. 浏览器如何渲染页面的：

   * 首先对html文件解析，生成 DOM 树，
   * 在对 css 文件解析，生成 style ruler，
   * 将 DOM tree 和 Style ruler 合为 render Tree；
   * 开始布局，确定每个元素的位置，
   * 开始绘制，呈现出元素

   

9. 浏览器输入 `地址`  到 `显示` 整个页面的过程

   <https://zhuanlan.zhihu.com/p/24913080> 

   1. 浏览器(chrome) 首先访问自身的 DNS 缓存，查看是否有该地址，有话直接访问 ip，没有则进行下一步。
   2. 访问系统的 DNS 缓存，有话直接访问 ip，没有则进行下一步。
   3. 访问系统的 host 文件(保存着 ip 和 域名的映射关系)，有话直接访问 ip，没有则进行下一步。
   4. 向宽带运营商服务器或域名服务器发送 `DNS` 解析请求(递归名称解析和迭代名称解析)， 获取域名的 ip 地址。
   5. 浏览器拿到 ip 地址，向该地址发送 TCP 连接(三次握手)。
   6. 连接成功后，浏览器向服务器发送 http 请求。
   7. 服务器处理请求，并返回结果。
   8. 浏览器接受响应的结果并进行处理，例如拿到 html， 浏览器通过 js引擎和 渲染引擎解析渲染页面，呈现在界面上。
   9. 浏览器断开连接(四次挥手)。



# HTTP

HTTP 全称 超文本传输协议(HyperText Transfer Protocol)。是互联网应用最广泛的一种网络协议。

1. 特点：

   * http 是无连接无状态的
   * 一般构建与 TCP/IP 协议之上的，默认为 80 端口

2. Http分为两部分，请求和响应

   1. 请求

      常用的几种请求方式：get、post、delete、put

      请求又由 3 个部分构成：状态行、请求头、请求正文

      GET 请求报文实例：

      ![](C:\Users\tzy\Desktop\note\img-git\get请求报文实例.png)

      * 状态行由 请求方法、路径、协议构成，每个元素以空格隔开

      * 请求头中提供一些参数：Cookie，用户代理信息，主机名等。(图中第2行到最后一行)

      * 请求正文中一般包含发送的数据，一般 get 请求会将信息放入 url 中，正文为空。post 请求会将信息放入正文中。

        请求头中常见参数：

        * Accept：指定客户端能接收的内容类型，如常见的text/html 等
        * Accept-Encoding：表示浏览器有能力解码的编码类型
        * Accept-language：表示浏览器支持的语言类型
        * Cache-Control：指定请求和响应遵循的缓存机制。
        * Connection：表示是否需要持久连接。(HTTP1.1默认持久连接，即keep-alive，HTTP1.0 则默认关闭，close)
        * cookie：用于会话跟踪
        * User-Agent：用户代理，提供服务端客户端的信息，如浏览器类型，CPU，操作系统等
        * Content-Type：内容类型，get请求无效，post中常见  application/x-www-form-urlencoded 普通表单提交，multipart/form-data 文件上传

   2.  响应

      响应 包括三个部分：状态行、响应头、响应正文

      响应实例：

      ![](C:\Users\tzy\Desktop\note\img-git\http响应实例.png)

      

# 网络安全

1. CSRF跨站点请求伪造(cross-site request forgery)

   用户在访问网站(A)后，没有登出(保留了session)，访问了危险网站B，B 网站带着session去请求网站A，达到模拟用户的操作目的。

2. XSS跨站脚本(cross site script)

   网站对用户提交的数据没有进行校验或欠缺，网页被嵌入了恶意代码，从而盗取用户资料等。

3. sql注入

   网站对用户提交的数据没有进行校验或欠缺，导致了攻击者可以提交一段数据库查询代码，根据程序返回的结果，获得一些他想得到的数据。 

4. 点击劫持

   攻击者将攻击的网站作为iframe，嵌入自己的网站中，通过覆盖透明的按钮，诱导用户点击

5. url跳转漏洞

   攻击者将url进行伪装(http://tieba.baidu.com/f/user/passport?jumpUrl=http://t.cn/RVTatrd )，使得用户降低警惕性，打开连接后跳转到恶意网址。

# HTML

1. CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值。

   * 行内元素有：a b span img input select strong（强调的语气） 

   * 块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p 

   * 空元素:br、meta、hr、link、input、img

     没有内容的 HTML 元素被称为空元素。空元素是在开始标签中关闭的。 

2. @import 和 link 区别

   * link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，`只能`用于加载CSS;   

   * 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载; 

   ```css
   <link rel="stylesheet" href="">
   <style>@import url(../vscodeTest/css/sasstest.css);</style>
   ```

3. html5 新标签

   canvas、video、audio、article、footer、header、nav、section

4. html 语义化的理解：

   语义化使页面的结构更清晰，更易阅读

5. 关闭 form 自动填充功能：指的是 input 输入时自动展开历史记录。

   将 input 标签的 autocomplet 设置为 false。

6. 使用 div 模拟 textarea：

   给 div 一个属性，contenteditable ，值为 true；

# CSS

1. 盒模型：

   ![盒模型](C:\Users\tzy\Desktop\note\img-git\盒模型.png)

   盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)； 

   区别：IE的content部分把 border 和 padding计算了进去; 

   IE 模型：

   - width/height = border + padding + content
   - css 设置： box-sizing：border-box

   标准模型：

   - width/height = content
   - css 设置： box-sizing：content-box

   js 获取宽高：

   - document.style.height/width 只能获取内联样式中设置的宽高，引入的 css 中设置的无法获取；
   - document.offsetHeight/width 获取实际的宽高(边框内包含边框的宽高)

2. 居中div

   垂直居中

   * 父元素 相对定位，子元素绝对定位，
     * top,bottom 设置为0，margin：auto 0；(水平居中也可以设置对应的属性)
     * 已知高度：top：50%，margin：-height/2px；
     * 未知高度：top：50%，transform：translateY(-50%);
   * 子元素浮动：
     * margin-top：50%，transform：translateY(-50%);
   * 多行文字居中：
     * display：table-cell；vertical-aline：middle；
   * 单行文字居中：
     * line-height：父元素高度；

   水平居中：

   * margin：0 auto；
   * display:flex; justify-content: center; （兼容性差，主要用于手机端）
   * 同垂直居中的方法

3. relative 和 absolute 定位的原点

   * absolute：绝对定位，相对于值不为 static 的最近的父元素；
   * relative：相对定位，相对原文档中的位置；
   * fixed：固定定位，相对于浏览器窗口；
   * static：默认值；
   * inherit：从父元素继承；

4. 左边定宽、右边自适应：

   * 父容器：diplay: flex; justify-content: space-between;
   * 父容器：diplay: flex; 定宽元素： flex: 0 0 300px;  自适应元素：flex: 1;
   * 自适应元素：width:  calc(100% - 定宽);
   * 定宽元素：float：left；自适应元素：margin-left：定宽；

5. css3 新特性：

   * 圆角、阴影；
   * 子代选择器：nth-child、last-child、first-child、属性选择器 [attrName="value"]
   * 媒体查询

6. 绝对定位、相对定位和浮动后元素的 display 值？

   block；用个 span 标签设置宽高背景色没有显示，再设置 `题中的属性` 显示了

7. Block Formatting Context(块级格式化上下文)

   创建方式：

   * 根元素(html)
   * display：table、table-cell、inline-block。。。
   * float：非 none 的值；
   * position：非 static 的值；
   * overflow：hidden；

   用处：

   * 清除浮动的影响；
     * 解决 margin(外边距) 合并的问题； 	

8. Formatting Context

   FC 是页面中一块独立渲染的区域，并有一套渲染规则决定其内的子元素如何定位，以及和其他元素的关系；

9. IFC (Inline formatting context 内联格式化上下文)

   创建方式：

   块级元素中仅包含内联元素；

   布局规则：

   * 子元素上下的 margin 不生效；左右生效；

   用处：

   * 水平居中：父元素设置 text-align：center 可以使 内联元素水平居中；
   * 垂直居中：使父元素内部的一个内联元素撑开盒子，给其他内联元素设置 vertical-align：middle，则这一行的所有内联元素都会垂直居中。

10. css 动画(Animations)

    通过一个 @keyframes 定义一个动画，在选择器中使用 animation 属性调用；

    animation 属性:

    * duration: 动画持续时间；
    * delay：延迟播放；
    * iteration-count：播放次数；infinite 无限播放
    * direction：动画的运动方向；
    * alternate：实现交替；
    * timing-function：速度曲线；

11. ::before 和 :after 中双冒号和单冒号有什么区别

    css 中的伪类一直用 ：表示，如：  :hover、:active等，在 css1 中已经有了伪元素用单个冒号；

    到了 css3 中修订：伪元素用两个冒号 `::` ,用来区分伪类和伪元素；

12. px/em/rem

    px：绝对单位，页面按精确的像素值展示；

    em：相对单位，页面按父元素的 font-size 大小计算，如果自身定义了 font-size 则按照自身的计算；就是说在一个页面，同是 1em 但展示的大小可能会不一样；

    rem：相对单位，页面按根元素(Html)的字体大小相同，css3 新加属性； 

     

  















# js

1. 图片懒加载：

   将所有图片的 src 放入一个相同的图片链接，真正的 src 放入一个自定义属性中，用 js 监听当图片进入视窗，将自定义的属性中的 `链接` 取出放入 src 中。

   主要方法：Element.getBoundingClientRect()

   

2. JS中attribute和property的区别:

   attribute: 获取 html 标签上的属性，主要用于自定义属性；

   property: 获取 DOM 元素中的属性，获取元素的原生属性；

   

3. 正则：贪婪 和 非贪婪模式

   `*` 贪婪模式：尽可能多的匹配

   `?*` 非贪婪模式：尽可能少的匹配

   ```javascript
   'abbbbbbabbbbbbba'.match(/a.*a/g);	// 贪婪
   // ["abbbbbbabbbbbbba"]
   
   'abbbbbbabbbbbbba'.match(/a.*?a/g);	// 非贪婪
   // ["abbbbbba"]
   ```

   

4. 堆栈溢出：

   执行环境中调用了大量函数，导致分配的调用栈空间被占满，导致堆栈溢出

5. 垃圾收集机制：

   标记清除：当变量进入环境，则给一个进入环境的标记，这时不会释放变量；当变量离开环境，则给一个离开环境的标记

   引用计数：当一个引用类型的值赋给一个变量，则这个值的引用次数加 1，当这个变量的值又取了另一个值，则引用次数减 1。

6. 回流和重绘：

   回流：当页面中的 HTML 结构发生变化(元素的位置和大小发生变化)，浏览器都要进行一次计算，重新渲染；`回流一定会触发重绘，反之不一定`

   重绘：当元素的一些样式发生修改(字体颜色，背景颜色)，只需要重新渲染当前元素。

   **提升性能的方法**

   - 通过文档碎片(DocumentFragment)保存所有需要插入的节点，再把文档碎片插入到 DOM 中，减少操作次数;
   - 用 display: none 隐藏元素，再进行操作，操作完在插入到 DOM 中；
   - 使用 innerHTML 保存所有节点，最后一次性替换；

7. 内存泄漏：

   定义：应用程序不再需要占用内存的时候，由于某些原因，内存没有被操作系统或可用内存池回收。 

   一些会产生内存泄漏的操作：

   * 闭包；
   * 两个引用对象通过自身的属性互相引用；
   * 不使用声明的关键字，直接定义了一个变量；
   * 计时器没有被回收；

8. const：

   声明时必须要初始化，且之后不能再改变值；

   

9. 阻止事件冒泡：

   w3c 的方法：e.stopPropagation()		IE 的方法：e.cancelBubble = true；

   取消默认事件：

   w3c 的方法：e.preventDefault()		IE 的方法：e.returnValue = false

   `return false` 同时阻止事件冒泡和默认事件

10. 闭包的作用：

    1. 能够访问函数所在环境上下文，阻止被回收；

    2. 私有化变量；

       ```javascript
       (function(){
           var a = 'tttzy';
           getA = function () {	// 没有加关键字，声明在全局
       		console.log(a)
           }
       })()
       ```

    3. 模拟块级作用域(同上)

    4. 创建模块

    缺点

    1. 内存消耗大，可能会引起内存泄漏

11. 显示原型和隐式原型：

    显示原型：构造函数上的 `prototype`

    隐式原型：对象中的 `\__proto__`

    object.\__proto__ === constructor.prototype

12. 创建对象的几种方式：

    * 工厂模式；
    * 构造函数模式；
    * 原型模式：方法和属性都在原型中添加；
    * 组合使用构造函数模式和原型模式：构造函数中用于添加属性，原型用于添加方法；
    * 动态原型模式：原型添加属性或方法写在构造函数中，需要先判断实例中是否有对象属性或方法，没有则执行原型添加；
    * 稳妥构造函数模式：类似工厂模式，外部无法直接访问属性，只能通过内部定义的方法访问；

13. 继承：

    * 原型链：子类型的原型指向父类型的实例

      问题：

      * 所有子类型的实例共享父类型的实例；
      * 创建子类型的实例，无法向父类型的构造函数传递参数；

    * 借用构造函数：子类型的构造函数中调用父类型的构造函数，通过 call 绑定 this；

      优点：

      * 可以向父类型的构造函数传参

      缺点：

      * 使用 instanceof 无法判断是否继承自父类；
      * 父类原型上的方法和属性无法继承；

    * 组合继承：同借用构造函数，子类构造函数的原型指向父类的实例对象；

      * 包含原型链和

        ## //TODO

14. 跨浏览器的事件处理程序：

    ```javascript
    var EventUtil = {
    	addHandler: function(element, type, handler) {
    		if(element.addEventListener) {
    			element.addEventListener(type, handler, false);
    		} else if(element.attachEvent) {
    			element.attachEvent('on' + type, handler);
    		} else {
    			element['on' + type] = handler;
    		}
    	},
    	removeHandler: function(element, type, handler) {
    		if(element.removeEventListener) {
    			element.removeEventListener(type, handler, false);
    		} else if(element.detachEvent) {
    			element.detachEvent('on' + type, handler);
    		} else {
    			element['on' + type] = null;
    		}
    	}
    }
    ```

15. 几种跨域解决方法：

    * jsonp

    * 修改 document.domain

    * window.name

    * html5 中的 window.postMessage 方法传送数据

      或者由后台去解决

16. 异步加载 js

    * script 标签中的 async = ‘async’
    * script 标签中的 defer = ‘defer’，只支持 IE
    * 创建script，插入到 DOM 中，加载完毕后执行 回调；

17. document.write() 和 innerHTML 的区别；

    * document.write() 会导致整个页面重绘
    * innerHTML 可以只重绘一部分；

18. async/await 相比于 Promise 的优势：

    * 代码读起来更加同步，Promise 的链式调用依然不够直观；
    * Promise 传递中间值非常麻烦。
    * 错误处理，async/await 可以用 try catch 捕捉；

19. 正则实现字符串 trim 方法：

    ```
    '  456  '.replace(/^\s*|\s*$/g)
    ```

    

    

    

    ​		

    

# React

1. React 的生命周期：

   * 挂载阶段

     constructor() 

     render() 该函数中最好只处理需要显示的东西，最好不要包含业务的处理代码；

     componentDidMount() 组件装载完成后执行该函数，该函数中可以获取并操作 DOM 节点

   * 更新阶段

     shouldComponentUpdate(nextProps, nextState) 两个参数都表示变化之后的 Props 和 State，该函数返回 Boolean，true 表示会触发重新渲染， false 表示不会触发；该生命周期可以用来对 React 程序的性能。

     render()

     componentDidUpdate(prevProps, prevState, snapshot)  

   * 卸载阶段

     componentWillUnmount() 用来清除一些不需要的东西，例如定时器

     [React生命周期]: http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/

2. setState 是异步还是同步的？

   有时是异步，有时是同步

   * 在合成事件和钩子中是 "异步" 的，在原生事件中同步的
     * 合成事件：在组件的 onClick 属性中添加事件
     * 原生事件： 使用 addEventListener 添加事件
   * setState 的异步并不是指，构成的代码是异步的，本身的执行是同步的，

3. 组件中的通信：

   * 父组件向子组件通信：父组件通过给子组件 props，向子组件通信；
   * 子组件向父组件通信：使用回调函数或者ref；
   * 兄弟组件：状态提升，用一个父组件管理这两个子组件；
   * 跨层传递：使用 context 可以在组件树中传递数据；
   * 全局：通过 redux 可以做全局的状态管理

4. 数组和 fragment 都可以返回多个 `元素`

5. 在某一时间节点调用 React 的 `render()` 方法，会创建一棵由 React 元素组成的`树`。 

6. DIFF：

   * 当对比两颗树的根节点元素类型不同：

     销毁根节点，后面的子节点也会被销毁

   * 当对比两颗树的根节点元素类型相同，属性不同：

     保留根节点，改变属性

   * 对比同类型的组件元素：

     当一个组件更新时，组件实例保持不变，这样 state 在跨越不同的渲染时保持一致。React 将更新该组件实例的 props 以跟最新的元素保持一致，并且调用该实例的 `componentWillReceiveProps()` 和 `componentWillUpdate()` 方法。

     下一步，调用 `render()` 方法，diff 算法将在之前的结果以及新的结果中进行递归。

7. 

看看：

1. ajax
2. 

-