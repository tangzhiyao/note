1. 1. 1. 微前端：https://zhuanlan.zhihu.com/p/78362028

         整体方案和这个很像: https://mp.weixin.qq.com/s/l17Uo6Q7up44uZI_VojFzw

         解决的问题：

         整合了多个项目，可以实现接近单页应用的体验, 之前通过把项目拆分出去解藕项目，但是会导致项目和项目之间跳转刷新；

         每个项目的初始化(全局配置)会随着时间导致不同(更新落后)，且未抽出的全局配置在更新后会导致修改比较麻烦；

         编译速度提升，提升开发体验；

         项目之间没有耦合，单独开发，单独部署

         

         

         1. 微前端注册项目过多时会不会产生什么问题？内存占用过多？卡顿？出现可以考虑进行卸载

         2. 实现方式:

            1. Npm 包形式: 将子项目通过 npm 包的形式打包发布，容器项目在打包构建时将子项目集成进去。
            2. iframe: 将子项目通过iframe嵌入容器项目中
            3. 路由方式: 容器项目运行时动态去加载子项目的路由与资源文件；
               * 通用式： 不限制技术栈
               * 特定式: 对

         3. 路由动态加载，输入url先加载容器，加载完成后匹配url，如果匹配上在去加载子项目资源与路由，重新再replace当前路径，此时容器和子项目都已经安装完成，触发了路由守卫，根据path匹配到子项目中的路由，展示子项目的相遇页面

         4. 运行时加载: 容器和子项目分开构建打包，在运行时容器去动态的加载子项目。

         5. 感觉通过HTMl entry似乎可以实现多框架

         6. 模块导入: 子项目和容器约定一个全局变量进行交互

         7. 应用隔离: 

         8. 1. 样式隔离:

            2. 1. 通过添加前缀(约定): 不同子项目添加不同前缀，但是如果第三方模块添加了全局的样式会导致问题(这个能不能在weboack中进行处理，第三方包再次根据包名进行处理)。 目前使用的是这种方式。
               2. Shadow DOM: 具有样式隔离，外部样式不会影响到shadowDOM里面的元素。但是这个方法有兼容性的问题；还有另一个问题: 例如antd 的 modal 是挂在在document.body 上，但是样式文件全在Shadow DOM 中没办法作用到外部。
               3. 离开应用的时候直接卸载样式文件: 这个方法没有上面的问题，且能够做到样式隔离。在多个应用同时存在时此方法会有问题

         9. 部署: 容器和子项目都各自进行部署(通过盘古)，将编译后的文件上传到cdn上，容器始终通过manifest.json找到入口文件进行加载.

         10. 





