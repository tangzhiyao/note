1. **js 基础：5种基本数据类型和1中复杂数据类型；**

- typeof 检测一个未声明的变量返回 undefined；
- null 被认为是一个空的对象的引用，所以 typeof 返回值为 Object；
- undefined 值派生于 null，所以使用 == 判断时返回 true；
- 浮点数会因为舍入导致数值不准确，所以不要测试某个特定浮点数的数值；![image.png](https://static.dingtalk.com/media/lALPDeC2uRCHlg1AzKM_163_64.png_879x10000.jpg)
- 当数值大小超过javascript的数值范围，会自动转化为 ±Infinity，Infinity 无法参加运算；
- 任何涉及到 NaN 的运算都返回 NaN；NaN 不等于任何值包括自身；字符串一旦创建就无法改变；
- 在非数值的值前使用一元操作符(正负号)会对这个值进行转换，![image.png](https://static.dingtalk.com/media/lALPDeC2uRCFurTMplU_85_166.png_879x10000.jpg)
- 对 null、NaN、undefined 使用 ！操作符，返回 true



2. **javascript基础：操作符和语句**

- 使用关系操作符时，如果一个操作符是数值，则会将另一个操作数转换为数值进行比较；

- 使用相等操作符，会进行强制转型；

- 函数调用时传入的参数个数没有限制，即使定义函数时只接受几个参数；

- 函数的参数可以由函数体内的 arguments 对象来访问参数数组(箭头函数中没有该对象，使用了 rest 代替)；

- arguments 的值永远与对应命名参数的值保持同步，例：参数 num 对应 arguments[0] ，修改 arguments[0] 的值会使 num 的值同步改变，但是修改 num 的值不会改 arguments[0] 的值，它们的内存空间是独立的。

- ECMAScript 中的所有参数传递都是值，不可能通过引用传递参数；(有点迷)

  理解：

  - 值传递：对于简单类型来说，将变量的值传递给参数，参数的改变不会对原变量的值产生变化。对于对象来说，则是把对象的引用传递给参数（类似把一个对象赋值给另一个变量），操作参数的内部属性会对原对象产生影响，但如果重新给参数赋值则对原对象没影响。
  - 引用传递：将变量的地址传递给参数，操作参数相当于操作变量。对参数的任何操作都会改变变量。

3. **javascript基础：执行环境及作用域链，引用类型；**

   - 执行环境(execution context 简称EC)

     - 执行环境一共有三种全局和局部(函数)作用域，还有一种 eval 环境，但因为其性能问题和安全问题不推荐使用；
     - 执行环境定义了变量或函数有权访问的其他数据，决定了他们各自的行为。每个执行环境都有一个与之关联的变量对象；
     - ECMAScript 所在宿主环境不同，执行环境也不同。在 Web 浏览器中全局执行环境中的变量对象为 window；
     - 执行环境中的代码执行完，该环境会被销毁，其中的变量和函数定义也会被销毁；

   - 作用域链

     - 执行作用域中对变量和函数访问的顺序：当前环境->上一级环境->...->全局环境。作用域链的前端永远是当前执行环境，全局环境永远在末尾；
     - 延长作用域链：某些语句会在当前作用域链前临时新增一个变量对象；

   - 当一个函数被调用时，一个新的上下文(EC)就会被创建，上下文的周期可以分为两个阶段：（参考：<https://www.cnblogs.com/lsgxeva/p/7976034.html> ）

     - 创建阶段：

       ![EC执行阶段 ](C:\Users\tzy\Desktop\note\img-git\EC创建阶段.png)

       在这个阶段，EC会创建执行对象(VO,  variable object)、作用域链和确定 this 指向；

       - 创建执行对象的过程：
         1. 建立 arguments 对象，检查当前上下文中的参数，建立该对象下的属性与属性值；
         2. 检查当前上下文中的函数声明，在变量对象中一函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名重复，则会被新的引用覆盖；
         3. 检查当前上下文中的变量声明，在变量对象中以变量名建立一个属性，值为 undefined（变量提升的原因）。`如果变量名已存在则跳过，无论值是什么`；

     - 执行阶段：

       创建完成后就开始执行代码，这时会完成变量赋值，函数引用和执行其他代码；![EC创建阶段](C:\Users\tzy\Desktop\note\img-git\EC执行阶段.png)注：变量 n 在函数 inner 之前声明但 inner 在前，可以看出函数的优先级高

     - 执行完毕后出栈，等待被回收

   - javascript 中没有块级作用域；

   - 垃圾收集：

     - javascript 具有自动垃圾收集机制；
     - 两种垃圾收集方式：标记清除和引用计数；
     - 解除引用：对不再使用的数据，将其设为 null；

     

4. 引用类型：

   - object 对象：

     - 通过对象字面量定义对象的时候，不会调用 Object 构造函数；    
     - 访问对象属性的两种方式：obj.name; obj['name']; 一般使用点表示法；

   - Array 类型：

     - 创建数组的三种方式：let arr = [];  let arr2 = new Array();  let arr3 = Array();  
     - 数组有一个 length 属性，用来记录数组元素个数。length 属性可以修改，用来删除末尾项或新加项；

   - Date 类型：

     - `var date = new Date()`
     - 原型方法：
       1. Date.parse()	接受一个表示日期的字符串作为参数，返回毫秒数。(从1970年1月1日0时到今)
       2. Date.UTC(年, 月(从0开始), 日, 时, 分, 秒, 毫秒) 前两个参数必须要，也返回毫秒数；
       3. Date.now() 获取当前时间，返回毫秒数；
     - 日期/时间组件方法：详见《javascript高级程序设计》5.3.3

   - 正则表达式：

     - 创建正则表达式：
       - var pattern = /正则表达式/标志
       - var pattern = new RegExp('正则表达式', '标志')    注意：参数1 是一个字符串，注意各种元字符的转义；参数2也是一个字符串；

   - Function 类型：

     - 定义函数：

       - 函数声明：

         `functiondeclaration(){}`

       - 函数表达式：    

         `varexpression = function(){}`

         二者作用相同，但是函数声明，只要定义了函数，在代码的任何位置都可以使用；表达式只有执行到赋值语句后才可以使用；

       - 使用 Function 构造函数：

         ```var constructor    = new Function(参数1, 参数2, ... , '函数体')```

         不推荐使用；

     - js 的函数没有重载：

       函数名相当于一个变量，重复定义函数则是后面的函数覆盖了前面函数，变量的引用被改变了(函数的实质也是对象)；

     - 函数的内部属性：

       - arguments：

         1. 包含着所有传入函数的参数；
         2. 有一个 callee 属性，该属性是一个指针，指向拥有这个 arguments 对象的函数；

       - this：

         this 指向调用该函数的环境对象；

       - caller：

         保存着调用当前函数的函数的引用(函数在全局中被引用则值为 null)；

     - 函数的属性和方法：

       1. length：保存着函数希望接收到的属性个数(定义函数时的参数个数);
       2. prototype：指向函数的原型，该属性不可枚举，因此无法用 for...in... 获取到；
       3. apply()：用于绑定特定的 this， 接受一个数组作为调用函数的参数；
       4. call()：作用同上，除了第一个参数，其余都作为调用函数的参数；

5. 